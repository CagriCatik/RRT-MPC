{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MPC RRT*","text":"<p>Welcome to the documentation for the MPC RRT* Motion Planning Framework. This package provides a modular reference implementation of a deterministic RRT* planner tightly coupled with a bicycle-model MPC controller. The documentation is organised as follows:</p> <ul> <li>Architecture \u2013 software modules, data flow and   configuration boundaries.</li> <li>MPC Theory \u2013 optimal control problem formulation and solver tuning strategies.</li> <li>Vehicle Dynamics \u2013 single-track model derivation and   linearisation steps.</li> <li>RRT* Planning \u2013 algorithmic details, heuristics and   determinism guarantees.</li> <li>Pipeline Usage \u2013 running the end-to-end system from CLI   and Python APIs.</li> <li>Pipeline Integration \u2013 end-to-end sequencing, data   contracts and MPC/RRT* interaction notes.</li> <li>Configuration \u2013 YAML schema, defaults and override tips.</li> <li>Developer Guide \u2013 contribution workflow and extension points.</li> </ul> <p>Each document is self-contained and includes references to the relevant code modules. All equations are provided using standard Markdown+LaTeX syntax.</p>"},{"location":"#capabilities-at-a-glance","title":"Capabilities at a Glance","text":"<ul> <li>Deterministic planning \u2013 reproducible RRT* exploration trees driven by a   shared random seed and deterministic collision checking on occupancy grids.</li> <li>Model-predictive control \u2013 OSQP-backed MPC with velocity, steering and   rate constraints, plus automatic relaxation strategies for infeasible   iterations.</li> <li>Visualization toolchain \u2013 Matplotlib utilities for RRT* trees, MPC   predictions and frame recording that exports to PNG or GIF.</li> <li>Headless automation \u2013 CLI entry points and Python APIs that run the full   pipeline while persisting artefacts under <code>plots/</code> for later inspection.</li> </ul>"},{"location":"#repository-layout","title":"Repository Layout","text":"<ul> <li><code>src/</code> \u2013 production code organised by domain (maps, planning, control,   pipeline orchestration, visualisation helpers).</li> <li><code>tests/</code> \u2013 deterministic unit tests covering geometry helpers, planning and   MPC building blocks.</li> <li><code>docs/</code> \u2013 this MkDocs site documenting architecture, algorithms and operator   workflows.</li> <li><code>examples/</code> \u2013 runnable scripts demonstrating pipeline usage and GIF   generation.</li> <li><code>assets/</code> &amp; <code>plots/</code> \u2013 input maps and generated artefacts respectively.</li> </ul>"},{"location":"#execution-modes","title":"Execution Modes","text":"<ul> <li>Command line \u2013 <code>python -m src.cli run</code> executes the full stack with live   visualisation; additional sub-commands target individual stages.</li> <li>Library \u2013 import <code>PipelineOrchestrator</code> or <code>run_pipeline</code> to embed the   planner/controller stack inside notebooks, experiments or services.</li> <li>Batch \u2013 schedule simulations headlessly by configuring <code>viz.backend: Agg</code>   and enabling frame recording for offline review.</li> </ul>"},{"location":"#observability","title":"Observability","text":"<p>The project configures structured logging via <code>src.logging_setup</code>. Core stages emit INFO-level progress updates (map preparation, planning iteration milestones and MPC roll-out summaries) so terminal output mirrors the high-level timeline of a run. Adjust log levels with <code>logging.basicConfig</code> or the helper <code>configure_logging()</code> to obtain more verbose DEBUG traces during development.</p>"},{"location":"architecture/","title":"Software Architecture","text":"<p>The refactored prototype is structured around composable stages so that map preparation, path planning, and trajectory tracking can evolve independently. The following diagram summarises the runtime composition.</p> <pre><code>flowchart LR\n    cfg[(config.PipelineConfig)] --&gt; cli[cli.run_pipeline]\n    cli --&gt; orch[pipeline.PipelineOrchestrator]\n    orch --&gt; mapStage[MapStage\\npipeline.map_stage]\n    orch --&gt; planStage[PlanningStage\\npipeline.planning_stage]\n    orch --&gt; trackStage[TrajectoryTracker\\npipeline.control_stage]\n    mapStage --&gt; maps[maps.*]\n    planStage --&gt; planning[planning.rrt*]\n    trackStage --&gt; control[control.*]\n    trackStage --&gt; viz[viz.visualization]\n    planning --&gt; common[common.geometry]\n    control --&gt; common\n</code></pre>"},{"location":"architecture/#module-responsibilities","title":"Module Responsibilities","text":""},{"location":"architecture/#pipeline","title":"<code>pipeline</code>","text":"<ul> <li>map_stage.py \u2013 encapsulates map generation, inflation and start/goal   derivation, returning immutable <code>MapArtifacts</code> that capture workspace bounds   together with both raw and inflated occupancy grids for sampling-based   planners.</li> <li>planning_stage.py \u2013 wraps RRT* execution and records the full <code>PlanResult</code>   alongside metadata.</li> <li>control_stage.py \u2013 performs MPC roll-outs with a structured recovery   strategy and optional visualisation hooks, yielding <code>TrackingResult</code>.</li> <li>orchestrator.py \u2013 coordinates the stages, manages Matplotlib lifecycle and   aggregates results into a <code>PipelineResult</code> that exposes both the plan and the   tracked states.</li> <li>artifacts.py \u2013 typed containers that document the data exchanged between   stages and enforce immutability where possible.</li> </ul>"},{"location":"architecture/#maps","title":"<code>maps</code>","text":"<ul> <li>generator.py \u2013 deterministic occupancy grid synthesis with optional   obstacle templates.</li> <li>inflate.py \u2013 obstacle dilation routines operating on binary grids or   grayscale images to provide metric safety margins.</li> <li>io.py \u2013 OpenCV-backed loading/saving helpers with explicit grayscale   semantics.</li> </ul>"},{"location":"architecture/#planning","title":"<code>planning</code>","text":"<ul> <li>rrt_star.py \u2013 deterministic RRT* with parent-indexed nodes (<code>PlanResult</code>).   Accepts a <code>PlannerParameters</code> dataclass to ensure reproducible seeds, tunable   metrics, and Catmull-Rom smoothing utilities.</li> <li>plan_result.py \u2013 data structures for returning the final path, node list   and metadata (iterations, goal index).</li> </ul>"},{"location":"architecture/#control","title":"<code>control</code>","text":"<ul> <li>vehicle_model.py \u2013 kinematic bicycle model and Jacobian linearisation   utilities.</li> <li>ref_builder.py \u2013 curvature-aware reference generation from geometric   polylines.</li> <li>mpc_controller.py \u2013 OSQP-backed MPC with soft constraints and structured   fallback via slack penalties.</li> </ul>"},{"location":"architecture/#viz","title":"<code>viz</code>","text":"<ul> <li>visualization.py \u2013 backend selection, RRT* rendering, MPC prediction plots   and tracked vehicle animation.</li> <li>vehicle_draw.py \u2013 reusable car footprint drawing primitives.</li> <li>record.py \u2013 frame capture helper and GIF assembly utilities for offline   rendering.</li> </ul>"},{"location":"architecture/#shared-utilities","title":"Shared Utilities","text":"<ul> <li>common/ \u2013 geometry resampling, yaw computation, plot path helpers and type   aliases.</li> <li>logging_setup.py \u2013 centralised logging configuration for CLI and unit   tests.</li> <li>config.py \u2013 dataclasses for map, planner, MPC and visualisation settings,   responsible for YAML deserialisation with <code>yaml.safe_load</code>.</li> <li>cli.py \u2013 thin fa\u00e7ade that wires the <code>PipelineOrchestrator</code> into Click   commands and exposes <code>run_pipeline</code> for direct API consumption.</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Configuration is loaded into <code>PipelineConfig</code>, providing typed access to    all parameters.</li> <li>Map Preparation uses <code>MapStage</code> to optionally generate a synthetic map,    inflate obstacles and construct a binary occupancy grid.</li> <li>Planning runs inside <code>PlanningStage</code>, executing <code>RRTStarPlanner</code>. The    stage applies Catmull-Rom smoothing to the returned waypoints (reusing the    planner spline settings) and packages the raw, pruned, and smoothed variants    into the <code>PlanResult</code> alongside the exploration tree.</li> <li>Reference Building &amp; Control happens inside <code>TrajectoryTracker</code>, which    converts the geometric path into an MPC reference, solves the QP with    recovery logic, and integrates the vehicle model forward in time.</li> <li>Visualisation / Recording is triggered from the control stage, reusing    the shared Matplotlib utilities and optional frame recorder. All artefacts are    persisted beneath <code>plots/</code> through the shared path helpers.</li> </ol> <p>This layered structure keeps responsibilities narrow, simplifies testing of each stage, and provides a clear seam for future planners or controllers.</p>"},{"location":"architecture/#runtime-sequence","title":"Runtime Sequence","text":"<ol> <li><code>PipelineOrchestrator.run()</code> configures the Matplotlib backend, instantiates    each stage with the loaded <code>PipelineConfig</code>, and measures wall-clock timings    for observability.</li> <li><code>MapStage.build()</code> produces immutable <code>MapArtifacts</code> that bundle the raw and    inflated occupancy grids, start/goal, inflation masks, and the workspace    extents used by planners operating in continuous space.</li> <li><code>PlanningStage.plan()</code> executes the configured algorithm (currently RRT*) and    returns a <code>PlanningArtifacts</code> wrapper. The planner output is smoothed    in-place so the downstream controller receives curvature-aware waypoints    without additional work.</li> <li><code>TrajectoryTracker.track()</code> converts the plan into an MPC reference, runs the    controller, and streams prediction frames to <code>viz.visualization</code> while    recording them when requested. The method returns a <code>TrackingResult</code>    containing the executed state history.</li> <li>The orchestrator aggregates the stage outputs into a <code>PipelineResult</code> so CLI    callers and notebooks can access the intermediate artefacts without probing    private attributes.</li> </ol> <p>This sequence mirrors the logical architecture diagram and doubles as a checklist when integrating the framework into external applications.</p>"},{"location":"architecture/#key-data-structures","title":"Key Data Structures","text":"<ul> <li><code>MapArtifacts</code> \u2013 immutable container for the raw and inflated occupancy   grids, start/goal pair, workspace bounds, and inflation mask used for   visualisation. It is always produced by <code>MapStage</code> before any planner is   invoked.</li> <li><code>PlanningArtifacts</code> \u2013 lightweight wrapper around <code>PlanResult</code>, ensuring   the orchestrator can extend metadata in the future without changing the stage   contract.</li> <li><code>TrackingResult</code> \u2013 holds the closed-loop state history returned by the MPC   tracker. Its minimal surface keeps storage costs low while still providing   enough data for plotting or log export.</li> <li><code>PipelineResult</code> \u2013 aggregates the previous artefacts, providing convenience   accessors for the computed path (<code>plan</code>) and tracked states (<code>states</code>).</li> </ul> <p>These dataclasses codify the coupling between stages and act as the canonical place to document new fields when extending the pipeline.</p>"},{"location":"architecture/#failure-handling-robustness","title":"Failure Handling &amp; Robustness","text":"<ul> <li>Map preparation regenerates the base map when <code>MapConfig.generate</code> is set   or the cached image is missing, ensuring deterministic builds across CI and   experiments.</li> <li>Planning propagates failure via <code>PlanResult.success</code>. The control stage   aborts early when this flag is false, preventing undefined behaviour.</li> <li>Tracking applies a two-stage relaxation inside <code>_solve_with_relaxation</code>   when OSQP reports infeasibility, widening rate limits and reducing the target   speed before retrying. Persistent infeasibility is logged as an error and the   loop exits gracefully.</li> <li>Visualisation is optional; when disabled the pipeline still produces a   complete <code>PipelineResult</code>, enabling batch evaluation on headless machines.</li> </ul>"},{"location":"architecture/#performance-determinism-considerations","title":"Performance &amp; Determinism Considerations","text":"<ul> <li>Planning randomness is seeded via <code>PlannerConfig.random_seed</code> and the RRT   parameters, making generated trees reproducible.</li> <li>Occupancy inflation and reference building operate on NumPy arrays, enabling   vectorised execution that scales with map size.</li> <li>The MPC controller warms starts OSQP, reuses linearised dynamics across the   horizon, and exposes penalty weights for slack variables so tuning efforts are   explicit in configuration rather than hard-coded.</li> <li>Stage-level logging reports timings, iteration counts, and controller   progress, providing a low-overhead feedback loop when profiling the system.</li> </ul>"},{"location":"architecture/#stage-contracts","title":"Stage Contracts","text":"Stage Input artefacts Output artefacts Failure handling <code>MapStage.build</code> <code>MapConfig</code> <code>MapArtifacts</code> (occupancy/start/goal/workspace/rectangles) Regenerates deterministic maps; raises when IO fails. <code>PlanningStage.plan</code> <code>MapArtifacts</code> <code>PlanningArtifacts</code> with <code>PlanResult</code> Returns <code>success=False</code>; downstream control aborts early. <code>TrajectoryTracker.track</code> <code>PlanningArtifacts</code>, <code>MapArtifacts</code> <code>TrackingResult</code> (state history) Graceful fallback via MPC relaxation or early termination. <p>The dataclasses live in <code>pipeline.artifacts</code> and intentionally hide mutable state. Each stage depends only on the public attributes of the previous stage, allowing replacement modules (e.g. a sampling-based planner or learned controller) to be wired in without touching the orchestration logic.</p>"},{"location":"architecture/#cross-cutting-concerns","title":"Cross-Cutting Concerns","text":""},{"location":"architecture/#configuration-loading","title":"Configuration Loading","text":"<p><code>config.PipelineConfig</code> binds YAML configuration to typed dataclasses. The CLI and API both call <code>load_config</code> or <code>default_config</code> before instantiating any pipeline stages. Because map generation persists outputs under <code>plots/</code>, the same configuration can be replayed offline and in CI. For reproducible experiments, version-control the YAML files alongside the source code.</p>"},{"location":"architecture/#determinism-logging","title":"Determinism &amp; Logging","text":"<ul> <li>RRT* sampling uses <code>numpy.random.default_rng</code> with an explicit seed from   <code>PlannerConfig</code>.</li> <li>MPC solves are deterministic given identical references and constraints; any   infeasibility triggers explicit WARN/ERROR logs.</li> <li>The orchestration stack logs INFO-level milestones (map, planning, control   duration) and per-stage progress so terminal output reflects pipeline health.   DEBUG-level logs expose finer detail such as individual obstacle placement.</li> </ul>"},{"location":"architecture/#quality-attributes","title":"Quality Attributes","text":"<ul> <li>Modularity \u2013 each stage is replaceable via dependency injection in   <code>PipelineOrchestrator</code>.</li> <li>Testability \u2013 deterministic seeds and dataclasses make unit tests stable   and fast.</li> <li>Observability \u2013 consolidated logging and plot artefacts provide both   textual and visual traces of a run.</li> <li>Extensibility \u2013 new planners/controllers can be integrated by implementing   the stage interfaces; configuration and artefacts already account for future   fields.</li> </ul>"},{"location":"architecture/#extension-ideas","title":"Extension Ideas","text":"<ul> <li>Swap <code>MapStage</code> for a ROS/Autoware map loader that still outputs   <code>MapArtifacts</code>.</li> <li>Introduce additional planners (e.g. lattice, A*) and register them in a small   factory keyed by configuration.</li> <li>Export telemetry (states, control inputs) to Arrow/Parquet to support offline   analysis pipelines or dataset generation.</li> </ul>"},{"location":"configuration/","title":"Configuration Reference","text":"<p>Configuration is expressed in YAML and deserialised via <code>yaml.safe_load</code> into a <code>PipelineConfig</code> dataclass. The schema mirrors the package structure.</p> <p>The CLI accepts a <code>--config</code> flag pointing to the YAML file. When omitted, the package falls back to <code>config.default_config()</code> which mirrors the defaults shown below. Programmatic entry points (<code>load_config</code>, <code>default_config</code>) share the same code path, so behaviour is consistent between notebooks, scripts and CLI usage.</p> <p>All relative paths resolve beneath the repository root. Map generation and plots use <code>src.common.paths</code> to ensure artefacts land in <code>plots/</code>, keeping workspaces tidy even when running multiple experiments.</p>"},{"location":"configuration/#map","title":"Map","text":"<pre><code>map:\n  map_file: occupancy_grid.png\n  inflated_map_file: occupancy_grid_inflated.png\n  map_resolution: 0.2   # metres per pixel\n  inflation_radius_m: 0.6\n  start: [50, 50]\n  goal_offset: [50, 50]\n  generate: false\n  size_m: [80.0, 80.0]\n  generator_resolution: 1.0\n  generator_seed: 4\n  rect_obstacles: []\n  rect_inflation_radius: 0.0\n</code></pre> <ul> <li><code>start</code>: pixel coordinates in image space (origin bottom-left after flip).</li> <li><code>goal_offset</code>: subtracted from the upper-right corner to place the goal.</li> <li><code>generate</code>: when <code>true</code> creates a deterministic synthetic map if the file is   absent.</li> <li><code>size_m</code> / <code>generator_resolution</code>: control the procedural generator. Use a   finer resolution when you need tighter obstacle placement; remember to update   <code>map_resolution</code> so the MPC scaling remains valid.</li> <li><code>rect_obstacles</code>: optional list of <code>[xmin, ymin, xmax, ymax]</code> rectangles for   continuous-space planners. Leave empty when relying solely on occupancy   grids.</li> <li><code>rect_inflation_radius</code>: Minkowski inflation (in map units) applied to each   rectangle before planning.</li> </ul> <p>When <code>generate: true</code>, the generator persists the base map to disk. Subsequent runs reuse the cached image unless <code>generate</code> stays true.</p>"},{"location":"configuration/#planner","title":"Planner","text":"<pre><code>planner:\n  algorithm: rrt_star\n  step_size: 10.0\n  goal_radius: 15.0\n  max_iterations: 3000\n  rewire_radius: 25.0\n  goal_sample_rate: 0.1\n  random_seed: 13\n  rrt_collision_step: 0.75\n  rrt_prune_path: true\n  rrt_spline_samples: 20\n  rrt_spline_alpha: 0.5\n  rrt_dedupe_tolerance: 1.0e-9\n</code></pre> <p><code>algorithm</code> selects the planner implementation. The pipeline now always executes the RRT* planner; non-<code>rrt_star</code> values are preserved for backwards compatibility but fall back with a warning. The remaining fields map directly to <code>PlannerParameters</code>, including the Catmull-Rom smoothing controls that run on every successful plan. All parameters honour deterministic seeds for reproducible runs.</p> <p>Runtime overrides can be applied without editing YAML by constructing <code>PipelineConfig.from_dict({...})</code> and merging dictionaries. This is useful when sweeping hyperparameters inside notebooks.</p>"},{"location":"configuration/#mpc","title":"MPC","text":"<pre><code>mpc:\n  wheelbase_m: 2.8\n  dt: 0.1\n  horizon: 12\n  v_px_s: 28.0\n  sim_steps: 600\n  q: [[4,0,0,0], [0,4,0,0], [0,0,0.6,0], [0,0,0,0.1]]\n  r: [[0.03,0], [0,0.25]]\n  q_terminal: [[8,0,0,0], [0,8,0,0], [0,0,1,0], [0,0,0,0.2]]\n  u_bounds: [[-35,35], [-0.6,0.6]]\n  v_bounds: [0, 90]\n  du_bounds: [[-12,12], [-0.15,0.15]]\n</code></pre> <p><code>wheelbase_m</code> is converted to pixels using <code>map_resolution</code>. Horizon and solver settings are passed to the MPC controller unchanged.</p> <p><code>sim_steps</code> controls the length of the closed-loop roll-out. The controller logs progress every ~10% of the configured steps so you can monitor long simulations without enabling debug logs.</p>"},{"location":"configuration/#visualisation","title":"Visualisation","text":"<pre><code>viz:\n  backend: Agg\n  prediction_pause: 0.05\n  animate_tree: true\n  record_frames: false\n  record_dir: frames\n</code></pre> <ul> <li><code>backend</code>: forwarded to <code>matplotlib.use</code> for headless execution.</li> <li><code>record_frames</code>: enables PNG frame capture of MPC predictions.</li> <li><code>prediction_pause</code>: dwell time between MPC predictions when visualising   interactively. Increase this to slow down animations for demos.</li> </ul> <p>Frame directories are timestamped when using the GIF generation CLI helper, so multiple recordings can coexist safely. Clean-up is automatic unless the <code>--keep-frames</code> flag is passed.</p>"},{"location":"configuration/#example-configuration-file","title":"Example Configuration File","text":"<pre><code>map:\n  map_file: assets/base_map.png\n  generate: true\nplanner:\n  random_seed: 123\nmpc:\n  horizon: 16\nviz:\n  backend: Agg\n</code></pre> <p>Unspecified fields fall back to defaults defined in <code>config.py</code>.</p>"},{"location":"configuration/#loading-precedence","title":"Loading Precedence","text":"<ol> <li>CLI flag <code>--config</code> (if provided).</li> <li><code>default_config()</code> values embedded in code.</li> <li>For programmatic usage, pass an already constructed <code>PipelineConfig</code> to    <code>run_pipeline</code> to bypass YAML entirely. This is useful in tests where inline    fixtures keep dependencies self-contained.</li> </ol>"},{"location":"developer_guide/","title":"Developer Guide","text":"<p>This guide explains how to contribute new features, extend planners/controllers and keep the prototype production-ready.</p>"},{"location":"developer_guide/#environment-tooling","title":"Environment &amp; Tooling","text":"<ol> <li>Python version \u2013 the project targets Python 3.11+. Use <code>pyproject.toml</code>    to install dependencies via <code>pip install -e .[dev]</code>.</li> <li>Linters/tests \u2013 execute <code>pytest</code> before submitting changes. Type hints    are enforced through the test-suite; prefer NumPy typing (<code>np.ndarray</code>) for    array-valued functions.</li> <li>Logging \u2013 route all log statements through <code>logging_setup.get_logger</code> to    keep formatting consistent across CLI and notebooks.</li> <li>Artefact storage \u2013 write any plots or generated maps via the helpers in    <code>src.common.paths</code>. They guarantee that outputs land under <code>plots/</code> and keep    test overrides (absolute paths) working as expected.</li> </ol>"},{"location":"developer_guide/#pipeline-extension-points","title":"Pipeline Extension Points","text":"<p>The orchestration layer is intentionally declarative. The relevant entry points are located in <code>src/pipeline/</code>.</p> <ul> <li><code>MapStage.build()</code> prepares <code>MapArtifacts</code> (raw/inflated occupancy grids,   inflation mask, start, goal, workspace bounds). Custom map sources should   implement a small helper that returns the same dataclass to remain compatible.</li> <li><code>PlanningStage.plan()</code> is where new planners can be inserted. Wrap your   implementation inside a class that consumes <code>MapArtifacts</code> and returns a   <code>PlanResult</code>.</li> <li><code>TrajectoryTracker.track()</code> performs MPC tracking. To experiment with a new   controller, implement the same method signature and update the orchestrator to   inject it. The <code>TrackingResult</code> dataclass is intentionally small so it can be   extended without breaking callers.</li> </ul>"},{"location":"developer_guide/#coding-conventions","title":"Coding Conventions","text":"<ul> <li>Use dataclasses to express configuration or artefacts exchanged between   modules. They provide structure and make unit tests deterministic.</li> <li>Stick to explicit imports within packages (e.g. <code>from ..logging_setup</code>) to   avoid circular dependencies.</li> <li>Prefer pure functions for geometry/math utilities; keep side effects in the   pipeline stages where logging and error handling are centralised.</li> </ul>"},{"location":"developer_guide/#numerical-stability-tips","title":"Numerical Stability Tips","text":"<ul> <li>Always rescale units when adjusting map resolution \u2013 the MPC operates in pixel   coordinates, so convert wheelbase and velocity bounds accordingly.</li> <li>When modifying <code>MPCParameters</code>, prefer the provided dataclasses and avoid   mutating controller state in-place. Construct a new controller with updated   bounds so that warm starts remain well-conditioned.</li> <li>Use the <code>curvature_slowdown</code> helper to keep yaw-rate constraints satisfied   when altering the reference trajectory.</li> </ul>"},{"location":"developer_guide/#testing-recommendations","title":"Testing Recommendations","text":"<ul> <li>Add unit tests in <code>tests/</code> mirroring the module layout (maps, planning,   control, pipeline). Each stage is deterministic and can be validated with   fixed seeds.</li> <li>For visual components, keep assertions numeric (e.g. number of predicted   states) rather than image-based snapshots. The <code>FrameRecorder</code> and   <code>assemble_gif</code> helpers automatically persist assets into <code>plots/</code> for manual   inspection.</li> </ul>"},{"location":"developer_guide/#observability-debugging","title":"Observability &amp; Debugging","text":"<ul> <li>Call <code>configure_logging(level)</code> during experiments to surface stage-level   progress information. The pipeline emits timing metrics per stage and MPC   progress snapshots at INFO level.</li> <li>Enable DEBUG logging when investigating map generation or planning; modules   emit granular detail such as obstacle placement and per-iteration costs.</li> <li>The CLI mirrors the logging output, so you can redirect to files for   long-running batches (<code>python -m src.cli run &gt; run.log</code>).</li> </ul>"},{"location":"developer_guide/#documentation-practices","title":"Documentation Practices","text":"<ul> <li>Update <code>docs/architecture.md</code> when adding new modules or changing the flow.</li> <li>Document configuration flags in <code>docs/configuration.md</code> and include default   values.</li> <li>Examples and notebooks should import <code>PipelineOrchestrator</code> from   <code>src.pipeline</code> to showcase the new API surface.</li> </ul> <p>By following these conventions the prototype remains maintainable while still supporting rapid algorithmic iteration.</p>"},{"location":"mpc_theory/","title":"MPC Theory","text":"<p>The MPC module solves a discrete-time optimal control problem for the kinematic bicycle model. The system state is \\(x = [x, y, \\psi, v]^T\\) and the control input is \\(u = [a, \\delta]^T\\). Given a time step \\(\\Delta t\\) and wheelbase \\(L\\), the nonlinear dynamics are</p> \\[ \\begin{aligned} x_{k+1} &amp;= x_k + \\Delta t\\, v_k \\cos(\\psi_k),\\\\ y_{k+1} &amp;= y_k + \\Delta t\\, v_k \\sin(\\psi_k),\\\\ \\psi_{k+1} &amp;= \\psi_k + \\Delta t\\, \\frac{v_k}{L} \\tan(\\delta_k),\\\\ v_{k+1} &amp;= v_k + \\Delta t\\, a_k. \\end{aligned} \\] <p>The controller linearises the dynamics around the current reference window</p> <p>\\((\\bar{x}_k, \\bar{u}_k)\\) to obtain</p> \\[ X_{k+1} = A_k X_k + B_k U_k + c_k, \\] <p>where \\(A_k = \\partial f / \\partial x\\), \\(B_k = \\partial f / \\partial u\\) and \\(c_k = f(\\bar{x}_k, \\bar{u}_k) - A_k \\bar{x}_k - B_k \\bar{u}_k\\). </p> <p>Forward Euler discretisation is sufficient at the 0.1 s time step used in this project.</p>"},{"location":"mpc_theory/#optimisation-problem","title":"Optimisation Problem","text":"<p>At each time step the controller solves</p> \\[ \\min_{X,U,s} \\sum_{k=0}^{N-1} \\left[(X_k - X_k^{\\mathrm{ref}})^T Q (X_k - X_k^{\\mathrm{ref}}) + U_k^T R U_k\\right] + (X_N - X_N^{\\mathrm{ref}})^T Q_N (X_N - X_N^{\\mathrm{ref}}) \\\\ + w_v \\sum_{k=0}^{N} s_{v,k}^2 + w_u \\sum_{k=0}^{N-1} \\lVert s_{u,k} \\rVert_2^2 + w_{\\Delta u} \\sum_{k=0}^{N-1} \\lVert s_{\\Delta u,k} \\rVert_2^2 \\] <p>subject to</p> \\[ \\begin{aligned} X_{k+1} &amp;= A_k X_k + B_k U_k + c_k,\\\\ X_{0} &amp;= x_0,\\\\ v_{\\min} - s_{v,k} &amp;\\le v_k \\le v_{\\max} + s_{v,k},\\\\ u_{\\min} - s_{u,k} &amp;\\le U_k \\le u_{\\max} + s_{u,k},\\\\ \\Delta u_{\\min} - s_{\\Delta u,k} &amp;\\le U_k - U_{k-1} \\le \\Delta u_{\\max} + s_{\\Delta u,k}, \\end{aligned} \\] <p>with all slack variables constrained to be non-negative. The slack weights are chosen to keep the problem a quadratic program while prioritising feasibility: \\(w_v = 10^3\\), \\(w_u = w_{\\Delta u} = 5\\times 10^2\\).</p>"},{"location":"mpc_theory/#solver-configuration","title":"Solver Configuration","text":"<p>OSQP is used with parameters tuned for fast convergence on the moderately sized QP (horizon 12, 4 states, 2 inputs):</p> <ul> <li><code>rho = 0.1</code></li> <li><code>alpha = 1.6</code></li> <li><code>adaptive_rho = True</code></li> <li><code>max_iter = 60000</code></li> <li><code>eps_abs = eps_rel = 10^{-3}</code></li> </ul> <p>If the solver reports infeasibility the pipeline reduces the reference velocity by 40% and relaxes rate bounds once before aborting. This mirrors the behaviour of the original prototype while keeping the logic testable.</p>"},{"location":"planning_rrt_star/","title":"RRT* Planning","text":"<p>The planner operates on binary occupancy grids where free cells have value <code>1</code> and obstacles <code>0</code>. Obstacle inflation is performed beforehand to guarantee the vehicle footprint remains within free space.</p>"},{"location":"planning_rrt_star/#deterministic-sampling","title":"Deterministic Sampling","text":"<p>A <code>PlannerParameters</code> dataclass encapsulates step size, goal radius, maximum iterations, rewire radius, goal sampling probability and a random seed. The seed initialises <code>numpy.random.default_rng</code>, ensuring runs are reproducible given the same map and configuration.</p>"},{"location":"planning_rrt_star/#algorithm","title":"Algorithm","text":"<ol> <li>Initialises the tree with the start node.</li> <li>At each iteration, samples the goal with probability <code>goal_sample_rate</code> or a    uniform random free-space point otherwise.</li> <li>Steers from the nearest node towards the sample with the configured <code>step</code>    length, discarding samples that leave map bounds or collide with obstacles.</li> <li>Chooses the best parent among nearby nodes (<code>rewire_radius</code>) by minimising    cumulative cost while preserving collision-free edges.</li> <li>Rewires neighbour nodes when routing through the new node reduces path cost.</li> <li>Declares success when a node enters the goal radius and the straight line to    the goal is collision-free. A dedicated goal node is appended to the tree for    consistent path extraction.</li> </ol> <p>The output <code>PlanResult</code> contains the ordered path (including start and goal), all nodes with parent indices and metadata such as iteration count. Additional fields expose the raw, pruned and smoothed paths used by alternative planners, but are empty for pure RRT* runs.</p>"},{"location":"planning_rrt_star/#collision-checking","title":"Collision Checking","text":"<p>Edges are discretised at one-pixel increments along the straight line between nodes. Any collision or out-of-bounds sample causes the candidate edge to be rejected. Inflation ensures straight-line interpolation between nodes respects safety margins.</p>"},{"location":"planning_rrt_star/#tuning-guidelines","title":"Tuning Guidelines","text":"<ul> <li>Step size: smaller values increase precision but require more iterations.   A step of 10 pixels balances computation and smoothness on the default map.</li> <li>Rewire radius: must be larger than the step size to allow meaningful cost   improvements. Radii between 15\u201330 pixels work well for 256\u00d7256 grids.</li> <li>Goal radius: should be large enough to tolerate discretisation while not   overshooting the target.</li> <li>Goal sampling rate: biases the tree towards the goal; 0.1\u20130.2 provides a   good compromise between exploration and convergence speed.</li> </ul> <p>Deterministic seeds make unit testing straightforward and allow regression tests across environments.</p>"},{"location":"system_integration/","title":"Pipeline Integration Deep Dive","text":"<p>This document connects the RRT* global planner with the MPC-based tracker by walking through the runtime hand-off points, contracts, and numerical considerations encoded in the source code. Use it when embedding the pipeline in research experiments or when swapping out individual components.</p>"},{"location":"system_integration/#end-to-end-control-flow","title":"End-to-End Control Flow","text":"<ol> <li>Configuration loading \u2013 <code>src.config.load_config()</code> deserialises YAML into    <code>PipelineConfig</code>, exposing strongly-typed stage parameters and default seeds    so reproducible runs do not depend on global state.</li> <li>Stage construction \u2013 <code>pipeline.orchestrator.PipelineOrchestrator.run()</code>    initialises <code>MapStage</code>, <code>PlanningStage</code>, and <code>TrajectoryTracker</code> with the    relevant sub-configs while configuring the requested Matplotlib backend. It    also logs per-stage timings for observability.</li> <li>Map preparation \u2013 <code>MapStage.build()</code> guarantees that a grayscale map    exists (regenerating it via <code>maps.generator.MapGenerator</code> when requested),    inflates obstacles, and returns a <code>MapArtifacts</code> dataclass bundling the    occupancy grid, start/goal pose, inflation masks, and workspace extents for    planners operating in continuous space.</li> <li>Planning \u2013 <code>PlanningStage.plan()</code> executes <code>planning.rrt_star.RRTStarPlanner</code>    on the inflated occupancy grid. It wraps the resulting <code>PlanResult</code> inside    <code>PlanningArtifacts</code> and applies optional Catmull-Rom smoothing so the control    stage receives curvature-aware waypoints without extra pre-processing.</li> <li>Tracking \u2013 <code>TrajectoryTracker.track()</code> converts the selected path into an    MPC reference using <code>control.ref_builder.build_reference</code>, solves the MPC via    <code>control.mpc_controller.MPCController</code>, and optionally streams prediction    frames to the visualisation helpers. The closed-loop state history is stored in    a <code>TrackingResult</code> for downstream analysis.</li> <li>Aggregation \u2013 The orchestrator returns <code>PipelineResult</code>, exposing    <code>.map</code>, <code>.plan</code>, and <code>.control</code> attributes so CLI commands, notebooks, or tests    can inspect intermediate artefacts without re-running stages.</li> </ol>"},{"location":"system_integration/#plannercontroller-interface","title":"Planner/Controller Interface","text":"<ul> <li><code>MapArtifacts</code> exposes both discrete (raw and inflated occupancy grids) and   continuous representations (workspace bounds). RRT* consumes the inflated grid   directly, while the inflation mask supports richer visualisation overlays.</li> <li><code>PlanResult.path</code> is guaranteed to contain the smoothed trajectory when   available. <code>PlanResult.raw_path</code> remains accessible, giving numerical   experiments access to the unsmoothed exploration tree.</li> <li><code>TrajectoryTracker</code> reads <code>PlanResult.success</code> before starting MPC tracking;   unsuccessful runs raise immediately so experiments can retry planning or report   the failure.</li> </ul>"},{"location":"system_integration/#mpc-execution-strategy","title":"MPC Execution Strategy","text":"<ul> <li><code>MPCConfig.to_parameters()</code> rescales the vehicle wheelbase into pixel units and   instantiates <code>MPCParameters</code>, keeping geometry consistent with the map   resolution provided by <code>MapConfig</code>.</li> <li><code>_solve_with_relaxation()</code> attempts a nominal solve first. If OSQP reports   infeasibility, the helper reduces the reference speed by 40% and widens rate   limits before retrying. Persistent failures are logged and bubble up as <code>None</code>   to terminate the loop gracefully.</li> <li>The main loop in <code>TrajectoryTracker.track()</code> integrates the discrete bicycle   model (<code>control.vehicle_model.f_discrete</code>) with the chosen control input and   records progress every 10% of the configured simulation steps. Distance-based   path advancement ensures the reference window slides forward only after the   vehicle leaves the current waypoint neighbourhood.</li> <li>Visualisation hooks (<code>viz.visualization.plot_prediction</code> and   <code>viz.record.FrameRecorder</code>) are optional and do not affect the returned   artefacts, enabling headless evaluation while still supporting offline GIF   generation.</li> </ul>"},{"location":"system_integration/#determinism-scaling-considerations","title":"Determinism &amp; Scaling Considerations","text":"<ul> <li>Planning and map generation use explicit RNG seeds (<code>PlannerConfig.random_seed</code>,   <code>MapConfig.generator_seed</code>), ensuring identical   trees and maps across runs when input parameters match.</li> <li>NumPy-based occupancy inflation and reference construction avoid Python loops,   keeping per-step latency low as map resolution increases.</li> <li>OSQP warm starts combined with modest horizons (default 15 steps) strike a   balance between responsiveness and solve time; adjust <code>MPCConfig.horizon</code> and   penalty matrices when targeting higher-speed manoeuvres.</li> </ul>"},{"location":"system_integration/#extending-the-pipeline","title":"Extending the Pipeline","text":"<ul> <li>Replace <code>MapStage</code> with a custom implementation that still returns   <code>MapArtifacts</code> to integrate external occupancy providers (e.g. ROS2 costmaps).</li> <li>Register new planners inside <code>PlanningStage.plan()</code> by dispatching on a config   key and returning a populated <code>PlanResult</code>.</li> <li>Swap the MPC with an alternative controller by implementing the   <code>TrajectoryTracker.track()</code> contract; <code>PipelineResult</code> will continue to expose   the new state history for analysis and tooling.</li> <li>Use the artefact dataclasses as the single source of truth for new metadata   fields (e.g. control inputs, cost metrics) so both CLI and API consumers pick   up changes transparently.</li> </ul>"},{"location":"usage_pipeline/","title":"Pipeline Usage Guide","text":"<p>This guide walks through running the full map \u2192 plan \u2192 control pipeline via the command line and Python API.</p>"},{"location":"usage_pipeline/#prerequisites","title":"Prerequisites","text":"<ol> <li>Install dependencies with <code>pip install -e .[dev]</code>.</li> <li>Ensure the default configuration (or your own YAML file) points to writable    locations for generated maps and visualisations. Relative paths are resolved    under the <code>plots/</code> directory automatically.</li> </ol>"},{"location":"usage_pipeline/#command-line-workflow","title":"Command Line Workflow","text":"<ol> <li>Generate Map (optional):</li> </ol> <pre><code>python -m src.cli generate-map\n</code></pre> <ol> <li>Inflate Obstacles:</li> </ol> <pre><code>python -m src.cli inflate-map\n</code></pre> <ol> <li>Run RRT* (saves tree and path plots):</li> </ol> <pre><code>python -m src.cli plan-path\n</code></pre> <ol> <li>Execute Full Pipeline:</li> </ol> <pre><code>python -m src.cli run\n</code></pre> <ol> <li>Export Simulation GIF (captures frames then assembles the animation):</li> </ol> <pre><code>python -m src.cli generate-gif\n</code></pre> <p>Pass a configuration file with <code>--config custom.yaml</code> to override defaults.</p>"},{"location":"usage_pipeline/#cli-options","title":"CLI Options","text":"<ul> <li><code>--config PATH</code> \u2013 load parameters from a YAML file.</li> <li><code>--help</code> \u2013 every sub-command documents its stage-specific arguments (e.g.   <code>generate-gif --help</code>).</li> <li><code>--keep-frames</code> (for <code>generate-gif</code>) \u2013 retain intermediate PNGs for manual   curation or post-processing.</li> </ul> <p>CLI invocations emit INFO-level logging to the terminal. Redirect to a file for batch runs (<code>python -m src.cli run --config sweep.yaml &gt; sweep.log</code>).</p>"},{"location":"usage_pipeline/#python-api","title":"Python API","text":"<pre><code>from src import PipelineOrchestrator, load_config\n\nconfig = load_config(\"configs/pipeline.yaml\")\norchestrator = PipelineOrchestrator(config)\nresult = orchestrator.run(visualize=False)\nprint(result.plan.success, len(result.states))\n</code></pre> <p>The helper <code>run_pipeline</code> is still available for quick scripts and returns the same <code>(PlanResult, states)</code> tuple as before. The <code>PipelineResult</code> object exposes the plan, intermediate artifacts and the tracked state history.</p> <p>Wrap simulations in <code>with configure_logging(...):</code> blocks or call <code>configure_logging(logging.DEBUG)</code> for verbose traces when debugging. The orchestrator logs stage durations and the controller reports progress at regular intervals, making notebook execution as observable as the CLI.</p>"},{"location":"usage_pipeline/#headless-rendering","title":"Headless Rendering","text":"<p>Set <code>viz.backend: \"Agg\"</code> in the configuration or call <code>configure_backend(\"Agg\")</code> before plotting. Enable frame recording with <code>viz.record_frames: true</code>; the PNG frames are saved in <code>plots/&lt;viz.record_dir&gt;/</code> and can be converted into GIFs via the CLI or <code>examples/generate_simulation_gif.py</code></p>"},{"location":"usage_pipeline/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If planning fails, inspect the logged iteration summaries to identify whether   the sampler exhausted iterations or collisions prevented goal connection.</li> <li>MPC infeasibility triggers warning logs; check whether <code>map_resolution</code>   changes demand a different <code>wheelbase_m</code> or relaxed rate bounds.</li> <li>Confirm generated maps exist under <code>plots/maps/</code> when running in headless   environments\u2014<code>MapStage</code> logs the resolved paths for quick verification.</li> </ul>"},{"location":"vehicle_dynamics/","title":"Vehicle Dynamics","text":"<p>The package uses a kinematic single-track (bicycle) model expressed in pixel coordinates. Mapping real-world wheelbase \\(L\\) in metres to pixels requires the occupancy grid resolution \\(r\\) (metres per pixel), yielding \\(L_{px} = L / r\\).</p>"},{"location":"vehicle_dynamics/#continuous-time-model","title":"Continuous-Time Model","text":"<p>With state \\(x = [x, y, \\psi, v]^T\\) and inputs \\(u = [a, \\delta]^T\\), the continuous dynamics are:</p> \\[ \\dot{x} = v \\cos \\psi, \\quad \\dot{y} = v \\sin \\psi, \\quad \\dot{\\psi} = \\frac{v}{L} \\tan \\delta, \\quad \\dot{v} = a. \\] <p>The model assumes small slip angles (front-wheel steering only) and is suitable for medium-speed manoeuvres typical of path tracking on occupancy grids.</p>"},{"location":"vehicle_dynamics/#discretisation","title":"Discretisation","text":"<p>Forward Euler discretisation with time step \\(\\Delta t\\) leads to the discrete model implemented in <code>vehicle_model.f_discrete</code>:</p> \\[ \\begin{aligned} x_{k+1} &amp;= x_k + \\Delta t\\, v_k \\cos \\psi_k,\\\\ y_{k+1} &amp;= y_k + \\Delta t\\, v_k \\sin \\psi_k,\\\\ \\psi_{k+1} &amp;= \\psi_k + \\Delta t\\, \\frac{v_k}{L} \\tan \\delta_k,\\\\ v_{k+1} &amp;= v_k + \\Delta t\\, a_k. \\end{aligned} \\]"},{"location":"vehicle_dynamics/#linearisation","title":"Linearisation","text":"<p>To support MPC, Jacobians of the discretised model are required. Around an operating point \\((\\bar{x}, \\bar{u})\\) the linearisation yields</p> \\[ A = \\frac{\\partial f}{\\partial x} = \\begin{bmatrix} 1 &amp; 0 &amp; -\\Delta t\\, v \\sin \\psi &amp; \\Delta t \\cos \\psi\\\\ 0 &amp; 1 &amp; \\Delta t\\, v \\cos \\psi &amp; \\Delta t \\sin \\psi\\\\ 0 &amp; 0 &amp; 1 &amp; \\Delta t\\, \\frac{\\tan \\delta}{L}\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}, \\quad B = \\frac{\\partial f}{\\partial u} = \\begin{bmatrix} 0 &amp; 0\\\\ 0 &amp; 0\\\\ 0 &amp; \\Delta t\\, \\frac{v}{L} \\sec^2 \\delta\\\\ \\Delta t &amp; 0 \\end{bmatrix}. \\] <p>The affine term is computed as</p> \\[ c = f(\\bar{x}, \\bar{u}) - A \\bar{x} - B \\bar{u}, \\] <p>ensuring exact matching at the linearisation point. These matrices feed directly into the MPC QP formulation.</p>"}]}